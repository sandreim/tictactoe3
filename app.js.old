import { ApiPromise, WsProvider } from '@polkadot/api';
import { web3Accounts, web3Enable, web3FromAddress } from '@polkadot/extension-dapp';
import { formatBalance } from '@polkadot/util';
import { Keyring } from '@polkadot/keyring';
import { mnemonicValidate, mnemonicToMiniSecret, cryptoWaitReady } from '@polkadot/util-crypto';

class PolkadotApp {
    constructor() {
        this.api = null;
        this.currentAccount = null;
        this.keyring = null;
        this.keyringPair = null; // For seed-based accounts
        this.accountType = null; // 'extension' or 'seed'
        this.unsubscribeBlocks = null;
        this.accountUpdateInterval = null;
        this.lastAccountUpdate = 0;
        this.accountUpdateThrottle = 3000; // Throttle updates to every 3 seconds max
        this.statusTimeout = null; // Track status message timeouts
        this.transactionHistory = []; // Store transaction history
        this.pendingTransactions = new Map(); // Track in-flight transactions by hash
        this.timingChart = null; // Chart.js instance
        
        // Tic Tac Toe game state
        this.gameBoard = Array(9).fill(null);
        this.currentPlayerSymbol = 'X';
        this.gameActive = true;
        this.currentGameId = null; // On-chain game ID
        this.gameStats = {
            xWins: 0,
            oWins: 0,
            draws: 0
        };
        this.opponentAddress = null;
        this.eventsSubscribed = false; // Track if we've subscribed to game events
        
        // Block rolling window
        this.blockWindow = []; // Store recent blocks
        this.maxBlocksInWindow = 50; // Maximum blocks to show
        this.finalizedBlockNumber = 0; // Track finalized block number
        this.blockTimestamps = new Map(); // Store block timestamps
        
        this.init();
    }

    init() {
        this.setupEventListeners();
        this.updateUI();
    }

    setupEventListeners() {
        // Connection button
        document.getElementById('connectBtn').addEventListener('click', () => {
            this.connectToChain();
        });

        // Wallet connection button
        document.getElementById('connectWalletBtn').addEventListener('click', () => {
            this.connectWallet();
        });

       
        // Update mode toggle
        // Clear history button
        document.getElementById('clearHistoryBtn').addEventListener('click', () => {
            this.clearTransactionHistory();
        });

        // Seed phrase buttons
        document.getElementById('useSeedBtn').addEventListener('click', () => {
            console.log('Use Seed button clicked');
            this.showSeedInput();
        });

        document.getElementById('importSeedBtn').addEventListener('click', () => {
            this.importFromSeed();
        });

        document.getElementById('cancelSeedBtn').addEventListener('click', () => {
            this.hideSeedInput();
        });

        // Tic Tac Toe game event listeners
        document.getElementById('resetGameBtn').addEventListener('click', () => {
            this.resetGame();
        });

        // Add click listeners to all cells
        document.querySelectorAll('.cell').forEach(cell => {
            cell.addEventListener('click', (e) => {
                const cellIndex = parseInt(e.target.getAttribute('data-cell'));
                this.handleCellClick(cellIndex);
            });
        });

        // Matchmaking buttons
        document.getElementById('playGameBtn').addEventListener('click', () => {
            this.playGame();
        });

        document.getElementById('cancelMatchmakingBtn').addEventListener('click', () => {
            this.cancelMatchmaking();
        });

        // Load game stats from localStorage
        this.loadGameStats();
    }

    async connectToChain() {
        const rpcUrl = document.getElementById('rpcUrl').value.trim();
        const connectBtn = document.getElementById('connectBtn');
        
        if (!rpcUrl) {
            this.showError('Please enter a valid RPC URL');
            return;
        }

        try {
            connectBtn.textContent = 'Connecting...';
            connectBtn.disabled = true;

            // Disconnect existing connection
            if (this.api) {
                await this.api.disconnect();
                this.stopAccountUpdates();
                // Hide block banner
                document.getElementById('blockBanner').classList.add('hidden');
            }

            // Create new connection
            const provider = new WsProvider(rpcUrl);
            this.api = await ApiPromise.create({ 
                provider,
                noInitWarn: true
            });
            
            // Ensure API is ready
            await this.api.isReady;

            // Get chain information
            const [chain, version] = await Promise.all([
                this.api.rpc.system.chain(),
                this.api.rpc.system.version()
            ]);

            // Update UI
            this.updateConnectionStatus(true, `Connected to ${chain}`);
            this.updateChainInfo(chain.toString(), version.toString());
            
            // Show block banner
            document.getElementById('blockBanner').classList.remove('hidden');
            
            // Start monitoring blocks
            this.subscribeToBlocks();
            
            // Subscribe to game events globally
            this.subscribeToGameEvents();

            connectBtn.textContent = 'Connected';
            connectBtn.disabled = false;

        } catch (error) {
            console.error('Connection error:', error);
            this.updateConnectionStatus(false, 'Connection failed');
            this.showError(`Failed to connect: ${error.message}`);
            // Hide block banner on error
            document.getElementById('blockBanner').classList.add('hidden');
            connectBtn.textContent = 'Connect';
            connectBtn.disabled = false;
        }
    }

    async connectWallet() {
        const connectWalletBtn = document.getElementById('connectWalletBtn');
        
        try {
            connectWalletBtn.textContent = 'Connecting...';
            connectWalletBtn.disabled = true;

            // Enable the extension
            const extensions = await web3Enable('Polkadot Parachain Explorer');
            
            if (extensions.length === 0) {
                throw new Error('No Polkadot extension found. Please install Polkadot{.js} extension.');
            }

            // Get accounts
            const accounts = await web3Accounts();
            
            if (accounts.length === 0) {
                throw new Error('No accounts found. Please create an account in your Polkadot extension.');
            }

            // Use the first account
            this.currentAccount = accounts[0];
            this.accountType = 'extension';
            
            // Update UI
            this.updateAccountInfo();
            connectWalletBtn.textContent = 'Connected';
            
            // Update account type display
            document.getElementById('accountType').textContent = 'üîå Extension Wallet';
           
            // Load user's games
            this.loadUserGames();

        } catch (error) {
            console.error('Wallet connection error:', error);
            this.showError(`Failed to connect wallet: ${error.message}`);
            connectWalletBtn.textContent = 'Connect Extension Wallet';
            connectWalletBtn.disabled = false;
        }
    }

    showSeedInput() {
        console.log('showSeedInput called');
        const seedInput = document.getElementById('seedInput');
        console.log('seedInput element:', seedInput);
        if (seedInput) {
            seedInput.classList.remove('hidden');
            console.log('Removed hidden class, classes:', seedInput.className);
            const seedPhrase = document.getElementById('seedPhrase');
            if (seedPhrase) {
                seedPhrase.focus();
            }
        } else {
            console.error('seedInput element not found!');
        }
    }

    hideSeedInput() {
        document.getElementById('seedInput').classList.add('hidden');
        document.getElementById('seedPhrase').value = '';
    }

    async importFromSeed() {
        const seedPhrase = document.getElementById('seedPhrase').value.trim();
        const importBtn = document.getElementById('importSeedBtn');
        
        if (!seedPhrase) {
            this.showError('Please enter a seed phrase');
            return;
        }

        try {
            importBtn.textContent = 'Importing...';
            importBtn.disabled = true;

            // Wait for crypto to be ready
            await cryptoWaitReady();

            // Initialize keyring if not already done
            if (!this.keyring) {
                this.keyring = new Keyring({ type: 'sr25519' });
            }

            // Hash the seed phrase with SHA-256 before using as seed
            // Create a key pair from the provided string (seed phrase)
            // This uses the Polkadot.js Keyring's addFromUri, which accepts a string (mnemonic, hex, or raw seed)
            this.keyringPair = this.keyring.addFromUri(seedPhrase);
            // const hashBuffer = await window.crypto.subtle.digest('SHA-256', new TextEncoder().encode(seedPhrase));
            // const hashedSeed = new Uint8Array(hashBuffer);
            // this.keyringPair = this.keyring.addFromSeed(hashedSeed);
            
            // Create account object compatible with extension format
            this.currentAccount = {
                address: this.keyringPair.address,
                meta: {
                    name: 'Seed Account',
                    source: 'seed'
                }
            };
            this.accountType = 'seed';

            console.log('Account created from seed string:', this.currentAccount.address);

            // Update UI
            this.updateAccountInfo();
            this.hideSeedInput();
            
            // Update account type display
            document.getElementById('accountType').textContent = 'üîë Seed Phrase Account';
            
            // Load user's games
            this.loadUserGames();

            importBtn.textContent = 'Create Account';
            importBtn.disabled = false;

        } catch (error) {
            console.error('Seed import error:', error);
            this.showError(`Failed to import seed: ${error.message}`);
            importBtn.textContent = 'Create Account';
            importBtn.disabled = false;
        }
    }

    async updateAccountInfo() {
        if (!this.api || !this.currentAccount) return;

        // Show loading indicator overlay
        const accountInfoDiv = document.getElementById('accountInfo');
        let loadingOverlay = document.getElementById('loadingOverlay');
        
        if (!loadingOverlay) {
            loadingOverlay = document.createElement('div');
            loadingOverlay.id = 'loadingOverlay';
            loadingOverlay.className = 'loading-indicator';
            loadingOverlay.textContent = 'üîÑ Updating...';
            accountInfoDiv.appendChild(loadingOverlay);
        } else {
            loadingOverlay.style.display = 'block';
        }

        try {
            // Get account balance and nonce
            const [accountInfo, nextNonce] = await Promise.all([
                this.api.query.system.account(this.currentAccount.address),
                this.api.rpc.system.accountNextIndex(this.currentAccount.address)
            ]);

            const { data: balance, nonce } = accountInfo;
            
            // Format balances
            const decimals = this.api.registry.chainDecimals[0];
            const unit = this.api.registry.chainTokens[0];
            
            // Convert to human-readable numbers (simple division by 10^decimals)
            const freeBalance = (balance.free / Math.pow(10, decimals)).toFixed(4);
            const reservedBalance = (balance.reserved / Math.pow(10, decimals)).toFixed(4);
            const lockedBalance = (balance.frozen / Math.pow(10, decimals)).toFixed(4);

            // Update UI with enhanced information
            document.getElementById('accountAddress').textContent = 
                `${this.currentAccount.address.slice(0, 8)}...${this.currentAccount.address.slice(-8)}`;
            
            // Update the balance display for header (compact)
            const balanceElement = document.getElementById('accountBalance');
            balanceElement.textContent = `${freeBalance} ${unit} | Nonce: ${nonce}`;
            
            document.getElementById('accountInfo').classList.remove('hidden');
            
            // Hide account selection buttons when account is connected
            document.querySelector('.account-options-header').classList.add('hidden');

            // Hide loading overlay
            const loadingOverlay = document.getElementById('loadingOverlay');
            if (loadingOverlay) {
                loadingOverlay.style.display = 'none';
            }

            // Add timestamp of last update
            const now = new Date().toLocaleTimeString();
            const existingTimestamp = document.getElementById('accountUpdateTime');
            if (existingTimestamp) {
                existingTimestamp.textContent = `Last updated: ${now}`;
            } else {
                const timestampDiv = document.createElement('div');
                timestampDiv.id = 'accountUpdateTime';
                timestampDiv.style.fontSize = '0.8rem';
                timestampDiv.style.color = '#718096';
                timestampDiv.style.marginTop = '8px';
                timestampDiv.textContent = `Last updated: ${now}`;
                document.getElementById('accountInfo').appendChild(timestampDiv);
            }

        } catch (error) {
            console.error('Error updating account info:', error);
            
            // Hide loading overlay on error
            const loadingOverlay = document.getElementById('loadingOverlay');
            if (loadingOverlay) {
                loadingOverlay.style.display = 'none';
            }
            
            // Show error message
            const balanceElement = document.getElementById('accountBalance');
            balanceElement.innerHTML = '<div style="color: #ef4444;">Error loading account info</div>';
        }
    }


    subscribeToBlocks() {
        if (!this.api) return;

        // Subscribe to new blocks (best blocks)
        this.unsubscribeBlocks = this.api.rpc.chain.subscribeNewHeads((header) => {
            this.updateBlockInfo(header);
            this.updateAccountInfo();
        });

        // Get finalized blocks
        this.api.rpc.chain.subscribeFinalizedHeads((header) => {
            this.updateFinalizedBlockInfo(header);
        });
    }

    updateBlockInfo(header) {
        const blockNumber = header.number.toNumber();
        const blockHash = header.hash.toString();
        const timestamp = Date.now();
        
        // Store timestamp
        this.blockTimestamps.set(blockNumber, timestamp);
        
        // Add to block window
        this.addBlockToWindow(blockNumber, blockHash, false);
    }

    updateFinalizedBlockInfo(header) {
        const blockNumber = header.number.toNumber();
        this.finalizedBlockNumber = blockNumber;
        
        // Mark finalized blocks in the window
        this.markFinalizedBlocks();
    }

    addBlockToWindow(blockNumber, blockHash, isFinalized) {
        // Check if block already exists
        const existingIndex = this.blockWindow.findIndex(b => b.number === blockNumber);
        if (existingIndex !== -1) {
            return; // Block already exists
        }

        // Add new block
        const block = {
            number: blockNumber,
            hash: blockHash,
            isFinalized: isFinalized || blockNumber <= this.finalizedBlockNumber
        };

        this.blockWindow.push(block);

        // Sort by block number (newest first for display)
        this.blockWindow.sort((a, b) => b.number - a.number);

        // Calculate how many blocks can fit
        const windowElement = document.getElementById('blockWindow');
        if (windowElement) {
            const containerWidth = windowElement.offsetWidth;
            const blockWidth = 42; // min-width of block-item
            const gap = 4; // gap between blocks
            const maxVisibleBlocks = Math.floor(containerWidth / (blockWidth + gap));
            
            // Keep only blocks that fit, drop oldest (end of sorted array)
            if (this.blockWindow.length > maxVisibleBlocks) {
                this.blockWindow = this.blockWindow.slice(0, maxVisibleBlocks);
                
                // Clean up timestamps for dropped blocks
                const remainingNumbers = new Set(this.blockWindow.map(b => b.number));
                for (const [num] of this.blockTimestamps) {
                    if (!remainingNumbers.has(num)) {
                        this.blockTimestamps.delete(num);
                    }
                }
            }
        }

        // Update UI
        this.renderBlockWindow();
    }

    markFinalizedBlocks() {
        // Update finalized status for all blocks
        this.blockWindow.forEach(block => {
            if (block.number <= this.finalizedBlockNumber) {
                block.isFinalized = true;
            }
        });

        // Update UI
        this.renderBlockWindow();
    }

    renderBlockWindow() {
        const windowElement = document.getElementById('blockWindow');
        const timelineElement = document.getElementById('blockTimeline');
        if (!windowElement || !timelineElement) return;

        // Render blocks
        windowElement.innerHTML = '';
        this.blockWindow.forEach((block, index) => {
            const blockDiv = document.createElement('div');
            blockDiv.className = 'block-item';
            if (block.isFinalized) {
                blockDiv.classList.add('finalized');
            }
            if (index === 0) {
                blockDiv.classList.add('new-block');
            }

            const shortHash = `${block.hash.slice(2, 6)}${block.hash.slice(-2)}`;
            
            blockDiv.innerHTML = `
                <div class="block-number">${block.number}</div>
                <div class="block-hash-short">${shortHash}</div>
            `;
            
            const timestamp = this.blockTimestamps.get(block.number);
            const timeStr = timestamp ? new Date(timestamp).toLocaleTimeString() : '';
            blockDiv.title = `Block #${block.number.toLocaleString()}\n${block.hash}\n${timeStr}\n${block.isFinalized ? '‚úì Finalized' : 'Pending'}`;

            windowElement.appendChild(blockDiv);
        });

        // Render timeline
        timelineElement.innerHTML = '';
        this.blockWindow.forEach((block, index) => {
            const tickDiv = document.createElement('div');
            tickDiv.className = 'timeline-tick';
            
            const timestamp = this.blockTimestamps.get(block.number);
            let deltaStr = '--';
            
            if (timestamp && index < this.blockWindow.length - 1) {
                // Get previous block (next in array since sorted newest first)
                const prevBlock = this.blockWindow[index + 1];
                const prevTimestamp = this.blockTimestamps.get(prevBlock.number);
                
                if (prevTimestamp) {
                    const deltaMs = timestamp - prevTimestamp;
                    const deltaSeconds = (deltaMs / 1000).toFixed(1);
                    deltaStr = `${deltaSeconds}s`;
                    
                    // Major tick if delta is >= 10 seconds
                    if (parseFloat(deltaSeconds) >= 10.0) {
                        tickDiv.classList.add('major');
                    }
                }
            }
            
            tickDiv.innerHTML = `
                <div class="tick-mark"></div>
                <div class="tick-time">${deltaStr}</div>
            `;

            timelineElement.appendChild(tickDiv);
        });
    }

    updateConnectionStatus(connected, message) {
        const statusIndicator = document.getElementById('statusIndicator');
        const statusText = document.getElementById('statusText');
        
        if (connected) {
            statusIndicator.classList.add('connected');
            statusText.textContent = message || 'Connected';
        } else {
            statusIndicator.classList.remove('connected');
            statusText.textContent = message || 'Disconnected';
        }
    }

    updateChainInfo(chainName, version) {
        document.getElementById('chainName').textContent = chainName;
        document.getElementById('chainVersion').textContent = version;
        document.getElementById('chainInfo').classList.remove('hidden');
    }

    validateTransactionForm() {
        const recipientAddress = document.getElementById('recipientAddress').value.trim();
        const transferAmount = document.getElementById('transferAmount').value;
        const sendBtn = document.getElementById('sendTransactionBtn');
        
        const isValid = recipientAddress.length > 0 && 
                       transferAmount > 0 && 
                       this.api && 
                       this.currentAccount;
        
        sendBtn.disabled = !isValid;
    }




    showTransactionStatus(type, message) {
        const statusDiv = document.getElementById('transactionStatus');
        const messageP = document.getElementById('transactionMessage');
        
        if (!statusDiv || !messageP) {
            console.error('Transaction status elements not found');
            return;
        }
        
        // Clear any existing timeout
        if (this.statusTimeout) {
            clearTimeout(this.statusTimeout);
            this.statusTimeout = null;
        }
        
        statusDiv.className = `transaction-status ${type}`;
        messageP.textContent = message;
        statusDiv.classList.remove('hidden');
        
        console.log(`üìã Status Update: [${type}] ${message}`);
        
        // Auto-hide success messages after 10 seconds
        if (type === 'success') {
            this.statusTimeout = setTimeout(() => {
                statusDiv.classList.add('hidden');
            }, 10000);
        }
        
        // Auto-hide error messages after 15 seconds
        if (type === 'error') {
            this.statusTimeout = setTimeout(() => {
                statusDiv.classList.add('hidden');
            }, 15000);
        }
    }

    showError(message) {
        alert(`Error: ${message}`);
    }

    addTransactionToHistory(txData) {
        // Check if transaction already exists by hash (only if hash is available)
        let existingIndex = -1;
        if (txData.hash) {
            existingIndex = this.transactionHistory.findIndex(
                tx => tx.hash && tx.hash === txData.hash
            );
        }
        
        if (existingIndex !== -1) {
            // Update existing transaction
            console.log(`Updating existing transaction in history: ${txData.hash?.slice(0, 10)}...`, txData.statusText);
            this.transactionHistory[existingIndex] = {
                ...this.transactionHistory[existingIndex],
                ...txData,
                timestamp: this.transactionHistory[existingIndex].timestamp // Keep original timestamp
            };
        } else {
            // Add to beginning of array (newest first)
            console.log(`Adding new transaction to history: ${txData.hash?.slice(0, 10) || txData.id}`, txData.statusText);
            this.transactionHistory.unshift({
                ...txData,
                timestamp: new Date()
            });
        }

        console.log(`Total transactions in history: ${this.transactionHistory.length}`);

        // Keep only last 50 transactions
        if (this.transactionHistory.length > 50) {
            this.transactionHistory = this.transactionHistory.slice(0, 50);
        }

        // Save to localStorage
        this.saveTransactionHistory();
        
        // Update UI
        this.renderTransactionHistory();
    }

    updateTransactionInHistory(txHash, updates) {
        const index = this.transactionHistory.findIndex(tx => tx.hash === txHash);
        if (index !== -1) {
            this.transactionHistory[index] = {
                ...this.transactionHistory[index],
                ...updates
            };
            this.saveTransactionHistory();
            this.renderTransactionHistory();
            return true;
        }
        return false;
    }

    renderTransactionHistory() {
        const historyDiv = document.getElementById('transactionHistory');
        
        console.log(`Rendering ${this.transactionHistory.length} transactions in history`);
        
        if (this.transactionHistory.length === 0) {
            historyDiv.innerHTML = '<p class="no-transactions">No transactions yet. Send your first transaction to see it here!</p>';
            this.updateChart(); // Update chart even if empty
            return;
        }

        // Update the timing chart with latest data
        this.updateChart();

        historyDiv.innerHTML = this.transactionHistory.map((tx, index) => {
            console.log(`[${index}] Rendering tx:`, tx.id, tx.hash?.slice(0, 10), tx.statusText);
            
            const time = tx.timestamp.toLocaleTimeString();
            const date = tx.timestamp.toLocaleDateString();
            const statusClass = tx.status || 'pending';
            const statusIcon = {
                'success': '‚úÖ',
                'pending': '‚è≥',
                'error': '‚ùå',
                'invalid': 'üö´'
            }[statusClass] || 'üìù';

            // Calculate timing display
            let timingInfo = '';
            if (tx.timing) {
                const parts = [];
                if (tx.timing.ready) {
                    const readyTime = ((tx.timing.ready - tx.timing.submitted) / 1000).toFixed(2);
                    parts.push(`Ready: ${readyTime}s`);
                }
                if (tx.timing.inBlock) {
                    const inBlockTime = ((tx.timing.inBlock - tx.timing.submitted) / 1000).toFixed(2);
                    parts.push(`InBlock: ${inBlockTime}s`);
                }
                if (tx.timing.finalized) {
                    const finalizedTime = ((tx.timing.finalized - tx.timing.submitted) / 1000).toFixed(2);
                    parts.push(`Finalized: ${finalizedTime}s`);
                }
                if (tx.timing.invalid) {
                    const invalidTime = ((tx.timing.invalid - tx.timing.submitted) / 1000).toFixed(2);
                    parts.push(`Invalid: ${invalidTime}s`);
                }
                if (parts.length > 0) {
                    timingInfo = `<div class="tx-timing">‚è±Ô∏è ${parts.join(' ‚Ä¢ ')}</div>`;
                }
            }

            return `
                <div class="tx-item ${statusClass}">
                    <div class="tx-header">
                        <span class="tx-status">${statusIcon} ${tx.statusText || 'Pending'}</span>
                        <span class="tx-time">${date} ${time}</span>
                    </div>
                    <div class="tx-details">
                        ${tx.from ? `<div><strong>From:</strong> ${tx.from.slice(0, 12)}...${tx.from.slice(-8)}</div>` : ''}
                        ${tx.to ? `<div><strong>To:</strong> ${tx.to.slice(0, 12)}...${tx.to.slice(-8)}</div>` : ''}
                        ${tx.amount ? `<div><strong>Amount:</strong> ${tx.amount}</div>` : ''}
                        ${tx.hash ? `<div><strong>Tx Hash:</strong> <a href="#" class="tx-hash" title="${tx.hash}">${tx.hash.slice(0, 10)}...${tx.hash.slice(-8)}</a></div>` : ''}
                        ${tx.finalizedBlockHash ? `<div><strong>Finalized:</strong> <span class="tx-hash" title="${tx.finalizedBlockHash}">${tx.finalizedBlockHash.slice(0, 10)}...${tx.finalizedBlockHash.slice(-8)}</span></div>` : 
                          tx.blockHash ? `<div><strong>Block:</strong> <span class="tx-hash" title="${tx.blockHash}">${tx.blockHash.slice(0, 10)}...${tx.blockHash.slice(-8)}</span></div>` : ''}
                        ${tx.error ? `<div><strong>Error:</strong> ${tx.error}</div>` : ''}
                    </div>
                    ${timingInfo}
                </div>
            `;
        }).join('');
    }

    saveTransactionHistory() {
        try {
            localStorage.setItem('polkadot_tx_history', JSON.stringify(
                this.transactionHistory.map(tx => ({
                    ...tx,
                    timestamp: tx.timestamp.toISOString()
                }))
            ));
        } catch (e) {
            console.error('Failed to save transaction history:', e);
        }
    }

    loadTransactionHistory() {
        try {
            const saved = localStorage.getItem('polkadot_tx_history');
            if (saved) {
                this.transactionHistory = JSON.parse(saved).map(tx => ({
                    ...tx,
                    timestamp: new Date(tx.timestamp)
                }));
                this.renderTransactionHistory();
            }
        } catch (e) {
            console.error('Failed to load transaction history:', e);
            this.transactionHistory = [];
        }
    }

    clearTransactionHistory() {
        if (confirm('Are you sure you want to clear all transaction history?')) {
            this.transactionHistory = [];
            localStorage.removeItem('polkadot_tx_history');
            
            // Hide chart stats
            document.getElementById('chartStats').classList.add('hidden');
            
            // Clear chart
            if (this.timingChart) {
                this.timingChart.data.labels = [];
                this.timingChart.data.datasets.forEach(dataset => {
                    dataset.data = [];
                });
                this.timingChart.update();
            }
            
            this.renderTransactionHistory();
            console.log('Transaction history cleared');
        }
    }

    updatePendingCount() {
        const pendingCountEl = document.getElementById('pendingCount');
        const count = this.pendingTransactions.size;
        
        if (count > 0) {
            pendingCountEl.textContent = `‚è≥ ${count} pending`;
            pendingCountEl.classList.remove('hidden');
        } else {
            pendingCountEl.classList.add('hidden');
        }
    }

    initChart() {
        const ctx = document.getElementById('timingChart');
        if (!ctx) return;

        this.timingChart = new Chart(ctx, {
            type: 'line',
            data: {
                datasets: [
                    {
                        label: 'Ready',
                        data: [],
                        borderColor: 'rgba(245, 158, 11, 1)',
                        backgroundColor: 'rgba(245, 158, 11, 0.8)',
                        borderWidth: 2,
                        pointRadius: 5,
                        pointHoverRadius: 7,
                        pointBackgroundColor: 'rgba(245, 158, 11, 0.8)',
                        pointBorderColor: 'rgba(245, 158, 11, 1)',
                        pointBorderWidth: 2,
                        tension: 0.3,
                        fill: false
                    },
                    {
                        label: 'InBlock',
                        data: [],
                        borderColor: 'rgba(59, 130, 246, 1)',
                        backgroundColor: 'rgba(59, 130, 246, 0.8)',
                        borderWidth: 2,
                        pointRadius: 5,
                        pointHoverRadius: 7,
                        pointBackgroundColor: 'rgba(59, 130, 246, 0.8)',
                        pointBorderColor: 'rgba(59, 130, 246, 1)',
                        pointBorderWidth: 2,
                        tension: 0.3,
                        fill: false
                    },
                    {
                        label: 'Finalized',
                        data: [],
                        borderColor: 'rgba(16, 185, 129, 1)',
                        backgroundColor: 'rgba(16, 185, 129, 0.8)',
                        borderWidth: 2,
                        pointRadius: 5,
                        pointHoverRadius: 7,
                        pointBackgroundColor: 'rgba(16, 185, 129, 0.8)',
                        pointBorderColor: 'rgba(16, 185, 129, 1)',
                        pointBorderWidth: 2,
                        tension: 0.3,
                        fill: false
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false,
                },
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'minute',
                            displayFormats: {
                                minute: 'HH:mm',
                                hour: 'HH:mm'
                            },
                            tooltipFormat: 'MMM dd, HH:mm:ss'
                        },
                        title: {
                            display: true,
                            text: 'Time'
                        },
                        ticks: {
                            maxRotation: 0,
                            autoSkipPadding: 20
                        }
                    },
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Latency (seconds)'
                        },
                        ticks: {
                            callback: function(value) {
                                return (value / 1000).toFixed(1) + 's';
                            }
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'top'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) {
                                    label += ': ';
                                }
                                const seconds = (context.parsed.y / 1000).toFixed(2);
                                label += seconds + 's';
                                label += ' (' + context.parsed.y + 'ms)';
                                return label;
                            }
                        }
                    }
                }
            }
        });
    }

    updateChart() {
        if (!this.timingChart) {
            this.initChart();
        }

        // Get all transactions with timing data (not just finalized)
        const allTxs = this.transactionHistory
            .filter(tx => tx.timing && tx.timestamp)
            .slice(0, 50) // Last 50 transactions
            .reverse(); // Oldest first for chronological time series

        if (allTxs.length === 0) {
            return;
        }

        // Prepare time series data - show points as soon as they're available
        // Ready: Show as soon as ready timestamp is available
        const readyData = allTxs
            .filter(tx => tx.timing.ready)
            .map(tx => ({
                x: tx.timestamp,
                y: tx.timing.ready - tx.timing.submitted,
                txId: tx.id
            }));

        // InBlock: Show as soon as inBlock timestamp is available
        const inBlockData = allTxs
            .filter(tx => tx.timing.inBlock)
            .map(tx => ({
                x: tx.timestamp,
                y: tx.timing.inBlock - tx.timing.submitted,
                txId: tx.id
            }));

        // Finalized: Show as soon as finalized timestamp is available
        const finalizedData = allTxs
            .filter(tx => tx.timing.finalized)
            .map(tx => ({
                x: tx.timestamp,
                y: tx.timing.finalized - tx.timing.submitted,
                txId: tx.id
            }));

        // Update chart datasets
        this.timingChart.data.datasets[0].data = readyData;
        this.timingChart.data.datasets[1].data = inBlockData;
        this.timingChart.data.datasets[2].data = finalizedData;
        this.timingChart.update();

        // Calculate and display statistics (only for completed data)
        const readyTimes = readyData.map(d => d.y);
        const inBlockTimes = inBlockData.map(d => d.y);
        const finalizedTimes = finalizedData.map(d => d.y);

        // Helper function to calculate stats
        const calcStats = (times) => {
            if (times.length === 0) return { min: 0, max: 0, avg: 0 };
            return {
                min: Math.min(...times),
                max: Math.max(...times),
                avg: times.reduce((a, b) => a + b, 0) / times.length
            };
        };

        const readyStats = calcStats(readyTimes);
        const inBlockStats = calcStats(inBlockTimes);
        const finalizedStats = calcStats(finalizedTimes);

        // Format time in seconds
        const formatTime = (ms) => ms > 0 ? `${(ms / 1000).toFixed(2)}s` : '-';

        // Show stats if we have any data
        if (readyTimes.length > 0 || inBlockTimes.length > 0 || finalizedTimes.length > 0) {
            // Ready stats
            document.getElementById('minReady').textContent = formatTime(readyStats.min);
            document.getElementById('maxReady').textContent = formatTime(readyStats.max);
            document.getElementById('avgReady').textContent = formatTime(readyStats.avg);
            
            // InBlock stats
            document.getElementById('minInBlock').textContent = formatTime(inBlockStats.min);
            document.getElementById('maxInBlock').textContent = formatTime(inBlockStats.max);
            document.getElementById('avgInBlock').textContent = formatTime(inBlockStats.avg);
            
            // Finalized stats
            document.getElementById('minFinalized').textContent = formatTime(finalizedStats.min);
            document.getElementById('maxFinalized').textContent = formatTime(finalizedStats.max);
            document.getElementById('avgFinalized').textContent = formatTime(finalizedStats.avg);
            
            document.getElementById('statsContent').classList.remove('hidden');
        }
    }

    updateUI() {
        // Initial UI state
        this.updateConnectionStatus(false);
        
        // Load transaction history
        this.loadTransactionHistory();
        
        // Initialize chart
        setTimeout(() => this.initChart(), 100);
    }

    // ===== TIC TAC TOE GAME METHODS =====

    async createOnChainGame() {
        if (!this.api || !this.currentAccount) {
            alert('Please connect to chain and wallet first');
            return;
        }

        const opponentAddress = document.getElementById('opponentAddressInput').value.trim();
        
        if (!opponentAddress) {
            alert('Please enter opponent address');
            return;
        }

        const createBtn = document.getElementById('createOnChainGameBtn');
        
        try {
            createBtn.disabled = true;
            createBtn.textContent = 'Creating Game...';

            console.log('Creating on-chain game with opponent:', opponentAddress);

            // Create unique transaction ID
            const txId = `game_create_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

            // Create transaction history entry
            const txHistoryData = {
                id: txId,
                from: this.currentAccount.address,
                to: opponentAddress,
                amount: 'Create Game',
                status: 'pending',
                statusText: 'Signing...',
                hash: null,
                blockHash: null,
                timing: {
                    submitted: Date.now(),
                    ready: null,
                    broadcast: null,
                    inBlock: null,
                    finalized: null,
                    invalid: null
                }
            };

            // Create the extrinsic
            const tx = this.api.tx.ticTacToe.createGame(opponentAddress);

            // Sign and send based on account type
            let unsub;
            const txCallback = async (result) => {
                let events = [];
                const { status,  dispatchError } = result;
                console.log(`[${txId}] Transaction status:`, status.type);
                
                // If transaction is invalid, update transaction history accordingly
                if (status.isInvalid) {
                    console.error(`[${txId}] Transaction is invalid`);
                    txHistoryData.timing.invalid = Date.now();
                    txHistoryData.status = 'error';
                    txHistoryData.statusText = 'Invalid';
                    this.addTransactionToHistory(txHistoryData);
                    createBtn.textContent = 'Create On-Chain Game';
                    createBtn.disabled = false;
                }
                // Update hash if availablefTransaction status
                if (!txHistoryData.hash && result.txHash) {
                    txHistoryData.hash = result.txHash.toHex();
                    console.log(`[${txId}] Transaction hash: ${txHistoryData.hash}`);
                }
                
                // Handle Ready status
                if (status.isReady) {
                    console.log(`[${txId}] Transaction ready`);
                    txHistoryData.timing.ready = Date.now();
                    txHistoryData.statusText = 'Ready';
                    this.addTransactionToHistory(txHistoryData);
                }

                if (status.isInBlock) {
                    console.log(`[${txId}] Game creation included in block at`, status.asInBlock.toString());
                    // Read all events from the block where the transaction was included
                    try {
                        const blockHash = status.asInBlock;
                        events = await this.api.query.system.events.at(blockHash);
                    } catch (err) {
                        console.error(`[${txId}] Failed to read events from block:`, err);
                    }
                    // Update timing
                    txHistoryData.timing.inBlock = Date.now();
                    txHistoryData.status = 'success';
                    txHistoryData.statusText = 'In Block';
                    txHistoryData.blockHash = status.asInBlock.toHex();
                    this.addTransactionToHistory(txHistoryData);
                    
                    // Check for errors
                    if (dispatchError) {
                        let errorInfo = '';
                        if (dispatchError.isModule) {
                            const decoded = this.api.registry.findMetaError(dispatchError.asModule);
                            errorInfo = `${decoded.section}.${decoded.name}: ${decoded.docs}`;
                        } else {
                            errorInfo = dispatchError.toString();
                        }
                        console.error('Transaction failed with error:', errorInfo);
                        alert(`Transaction failed: ${errorInfo}`);
                        createBtn.textContent = 'Create On-Chain Game';
                        createBtn.disabled = false;
                        unsub();
                        return;
                    }
                    
                    // Find the GameCreated event
                    let gameCreated = false;
                    for (const { event } of events) {
                        console.log('Event:', event.section, event.method, event.toHuman());
                        
                        // Try multiple ways to detect the event
                        const isTicTacToeEvent = event.section === 'ticTacToe' || event.section === 'tictactoe';
                        const isGameCreatedEvent = event.method === 'GameCreated';
                        
                        if (isTicTacToeEvent && isGameCreatedEvent) {
                            console.log('Found GameCreated event!');
                            const [gameId, playerX, playerO] = event.data;
                            this.currentGameId = gameId.toNumber();
                            
                            console.log(`Game created! ID: ${this.currentGameId}, PlayerX: ${playerX}, PlayerO: ${playerO}`);
                            
                            // Re-enable button and reset text BEFORE setupGame hides the section
                            createBtn.textContent = 'Create On-Chain Game';
                            createBtn.disabled = false;
                            
                            gameCreated = true;
                            
                            // Join the game we just created (don't wait for finality)
                            try {
                                await this.setupGame(this.currentGameId, playerX.toString(), playerO.toString());
                            } catch (error) {
                                console.error('Error setting up game:', error);
                                alert(`Error joining game: ${error.message}`);
                            }
                            
                            // Unsubscribe
                            unsub();
                            break;
                        }
                        
                        // Keep the old check as backup
                        if (this.api.events.ticTacToe && this.api.events.ticTacToe.GameCreated && this.api.events.ticTacToe.GameCreated.is(event)) {
                            const [gameId, playerX, playerO] = event.data;
                            this.currentGameId = gameId.toNumber();
                            
                            console.log(`Game created! ID: ${this.currentGameId}, PlayerX: ${playerX}, PlayerO: ${playerO}`);
                            
                            // Re-enable button and reset text BEFORE setupGame hides the section
                            createBtn.textContent = 'Create On-Chain Game';
                            createBtn.disabled = false;
                            
                            gameCreated = true;
                            
                            // Join the game we just created (don't wait for finality)
                            try {
                                await this.setupGame(this.currentGameId, playerX.toString(), playerO.toString());
                            } catch (error) {
                                console.error('Error setting up game:', error);
                                alert(`Error joining game: ${error.message}`);
                            }
                            
                            // Unsubscribe
                            unsub();
                            break;
                        }
                    }
                    
                    if (!gameCreated) {
                        console.warn('GameCreated event not found in events! Trying to query nextGameId...');
                        
                        // Fallback: Query the chain to get the latest game ID
                        try {
                            // Wait for the GameCreated event and get the gameId from there
                            let foundGameId = null;
                            for (const { event } of events) {
                                // Support both new and old event formats
                                if (
                                    (this.api.events.ticTacToe && this.api.events.ticTacToe.GameCreated && this.api.events.ticTacToe.GameCreated.is(event)) ||
                                    (event.section === 'ticTacToe' && event.method === 'GameCreated')
                                ) {
                                    const [gameId, playerX, playerO] = event.data;
                                    // Check if our address is one of the players
                                    if (
                                        playerX.toString() === this.currentAccount.address ||
                                        playerO.toString() === this.currentAccount.address
                                    ) {
                                        foundGameId = gameId.toNumber();
                                        break;
                                    }
                                }
                            }
                            const latestGameId = foundGameId !== null ? foundGameId : -1;
                            
                            if (latestGameId >= 0) {
                                console.log(`Queried latest game ID: ${latestGameId}`);
                                
                                // Fetch the game details
                                const game = await this.api.query.ticTacToe.games(latestGameId);
                                if (game.isSome) {
                                    const gameData = game.unwrap();
                                    const playerXAddr = gameData.playerX || gameData.player_x;
                                    const playerOAddr = gameData.playerO || gameData.player_o;
                                    const playerX = playerXAddr.toString();
                                    const playerO = playerOAddr.toString();
                                    
                                    console.log(`Found game ${latestGameId}: X=${playerX}, O=${playerO}`);
                                    
                                    // Check if current account is in this game
                                    if (playerX === this.currentAccount.address || playerO === this.currentAccount.address) {
                                        console.log('This is our game! Joining...');
                                        this.currentGameId = latestGameId;
                                        
                                        // Re-enable button
                                        createBtn.textContent = 'Create On-Chain Game';
                                        createBtn.disabled = false;
                                        
                                        // Join the game
                                        await this.setupGame(latestGameId, playerX, playerO);
                                        gameCreated = true;
                                    }
                                }
                            }
                        } catch (queryError) {
                            console.error('Error querying game state:', queryError);
                        }
                        
                        if (!gameCreated) {
                            createBtn.textContent = 'Create On-Chain Game';
                            createBtn.disabled = false;
                        }
                        unsub();
                    }
                }

                if (status.isFinalized) {
                    console.log(`[${txId}] Game creation finalized`);
                    
                    // Update timing
                    txHistoryData.timing.finalized = Date.now();
                    txHistoryData.statusText = 'Finalized ‚úì';
                    txHistoryData.finalizedBlockHash = status.asFinalized.toHex();
                    
                    // Update in history
                    this.updateTransactionInHistory(txHistoryData.hash, {
                        status: 'success',
                        statusText: 'Finalized ‚úì',
                        finalizedBlockHash: status.asFinalized.toHex(),
                        timing: txHistoryData.timing
                    });
                    
                }
            };

            if (this.accountType === 'seed') {
                unsub = await tx.signAndSend(this.keyringPair, txCallback);
            } else {
                const injector = await web3FromAddress(this.currentAccount.address);
                unsub = await tx.signAndSend(
                    this.currentAccount.address,
                    { signer: injector.signer },
                    txCallback
                );
            }

        } catch (error) {
            console.error('Error creating game:', error);
            alert(`Failed to create game: ${error.message}`);
            createBtn.textContent = 'Create On-Chain Game';
            createBtn.disabled = false;
        }
    }

    async playGame() {
        if (!this.api || !this.currentAccount) {
            alert('Please connect to chain and wallet first');
            return;
        }

        const playBtn = document.getElementById('playGameBtn');
        const cancelBtn = document.getElementById('cancelMatchmakingBtn');
        const statusDiv = document.getElementById('matchmakingStatus');
        
        try {
            playBtn.disabled = true;
            playBtn.textContent = 'JOINING QUEUE...';

            console.log('Joining matchmaking queue...');

            // Create unique transaction ID
            const txId = `matchmaking_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

            // Create transaction history entry
            const txHistoryData = {
                id: txId,
                from: this.currentAccount.address,
                to: 'Matchmaking',
                amount: 'Start Game',
                status: 'pending',
                statusText: 'Signing...',
                hash: null,
                blockHash: null,
                timing: {
                    submitted: Date.now(),
                    ready: null,
                    broadcast: null,
                    inBlock: null,
                    finalized: null,
                    invalid: null
                }
            };

            // Create the extrinsic (call_index 2 = playGame)
            const tx = this.api.tx.ticTacToe.playGame();

            // Sign and send based on account type
            let unsub;
            const txCallback = async (result) => {
                let events = [];
                const { status, dispatchError } = result;
                console.log(`[${txId}] Transaction status:`, status.type);
                
                // If transaction is invalid, update transaction history accordingly
                if (status.isInvalid) {
                    console.error(`[${txId}] Transaction is invalid`);
                    txHistoryData.timing.invalid = Date.now();
                    txHistoryData.status = 'error';
                    txHistoryData.statusText = 'Invalid';
                    this.addTransactionToHistory(txHistoryData);
                    playBtn.textContent = 'START GAME';
                    playBtn.disabled = false;
                    statusDiv.classList.add('hidden');
                }
                
                // Update hash if available
                if (!txHistoryData.hash && result.txHash) {
                    txHistoryData.hash = result.txHash.toHex();
                    console.log(`[${txId}] Transaction hash: ${txHistoryData.hash}`);
                }
                
                // Handle Ready status
                if (status.isReady) {
                    console.log(`[${txId}] Transaction ready`);
                    txHistoryData.timing.ready = Date.now();
                    txHistoryData.statusText = 'Ready';
                    this.addTransactionToHistory(txHistoryData);
                }

                if (status.isInBlock) {
                    console.log(`[${txId}] Matchmaking request included in block at`, status.asInBlock.toString());
                    // Read all events from the block where the transaction was included
                    try {
                        const blockHash = status.asInBlock;
                        events = await this.api.query.system.events.at(blockHash);
                    } catch (err) {
                        console.error(`[${txId}] Failed to read events from block:`, err);
                    }
                    // Update timing
                    txHistoryData.timing.inBlock = Date.now();
                    txHistoryData.status = 'success';
                    txHistoryData.statusText = 'In Block';
                    txHistoryData.blockHash = status.asInBlock.toHex();
                    this.addTransactionToHistory(txHistoryData);
                    
                    // Check for errors
                    if (dispatchError) {
                        let errorInfo = '';
                        if (dispatchError.isModule) {
                            const decoded = this.api.registry.findMetaError(dispatchError.asModule);
                            errorInfo = `${decoded.section}.${decoded.name}: ${decoded.docs}`;
                        } else {
                            errorInfo = dispatchError.toString();
                        }
                        
                        console.error(`[${txId}] Error:`, errorInfo);
                        alert(`Failed to join matchmaking: ${errorInfo}`);
                        
                        playBtn.textContent = 'START GAME';
                        playBtn.disabled = false;
                        statusDiv.classList.add('hidden');
                        cancelBtn.classList.add('hidden');
                        
                        unsub();
                        return;
                    }
                    
                    // Check for events
                    let joinedQueue = false;
                    let gameCreated = false;
                    
                    for (const { event } of events) {
                        console.log('events', events);
                        
                        // Check if player joined queue
                        if (
                            (this.api.events.ticTacToe && this.api.events.ticTacToe.PlayerJoinedQueue && this.api.events.ticTacToe.PlayerJoinedQueue.is(event)) ||
                            (event.section === 'ticTacToe' && event.method === 'PlayerJoinedQueue')
                        ) {
                            const [player] = event.data;
                            if (player.toString() === this.currentAccount.address) {
                                console.log('Joined matchmaking queue, waiting for opponent...');
                                joinedQueue = true;
                                
                                // Show waiting status
                                statusDiv.classList.remove('hidden');
                                playBtn.classList.add('hidden');
                                cancelBtn.classList.remove('hidden');
                            }
                        }
                        
                        // Check if game was created (matched immediately)
                        if (
                            (this.api.events.ticTacToe && this.api.events.ticTacToe.GameCreated && this.api.events.ticTacToe.GameCreated.is(event)) ||
                            (event.section === 'ticTacToe' && event.method === 'GameCreated')
                        ) {
                            const [gameId, playerX, playerO] = event.data;
                            // Check if our address is one of the players
                            if (
                                playerX.toString() === this.currentAccount.address ||
                                playerO.toString() === this.currentAccount.address
                            ) {
                                console.log(`Game created via matchmaking! Game ID: ${gameId}`);
                                gameCreated = true;
                                this.currentGameId = gameId.toNumber();
                                
                                // Hide matchmaking UI
                                statusDiv.classList.add('hidden');
                                playBtn.classList.remove('hidden');
                                cancelBtn.classList.add('hidden');
                                playBtn.textContent = 'START GAME';
                                playBtn.disabled = false;
                                
                                // Join the game
                                await this.setupGame(this.currentGameId, playerX.toString(), playerO.toString());
                            }
                        }
                    }
                    
                    if (!joinedQueue && !gameCreated) {
                        playBtn.textContent = 'START GAME';
                        playBtn.disabled = false;
                        statusDiv.classList.add('hidden');
                    }
                    
                    unsub();
                }

                if (status.isFinalized) {
                    console.log(`[${txId}] Matchmaking finalized`);
                    
                    // Update timing
                    txHistoryData.timing.finalized = Date.now();
                    txHistoryData.statusText = 'Finalized ‚úì';
                    txHistoryData.finalizedBlockHash = status.asFinalized.toHex();
                    
                    // Update in history
                    this.updateTransactionInHistory(txHistoryData.hash, {
                        status: 'success',
                        statusText: 'Finalized ‚úì',
                        finalizedBlockHash: status.asFinalized.toHex(),
                        timing: txHistoryData.timing
                    });
                }
            };

            if (this.accountType === 'seed') {
                unsub = await tx.signAndSend(this.keyringPair, txCallback);
            } else {
                const injector = await web3FromAddress(this.currentAccount.address);
                unsub = await tx.signAndSend(
                    this.currentAccount.address,
                    { signer: injector.signer },
                    txCallback
                );
            }

        } catch (error) {
            console.error('Error joining matchmaking:', error);
            alert(`Failed to join matchmaking: ${error.message}`);
            playBtn.textContent = 'Find Opponent';
            playBtn.disabled = false;
            statusDiv.classList.add('hidden');
            cancelBtn.classList.add('hidden');
        }
    }

    async cancelMatchmaking() {
        if (!this.api || !this.currentAccount) {
            alert('Please connect to chain and wallet first');
            return;
        }

        const cancelBtn = document.getElementById('cancelMatchmakingBtn');
        const playBtn = document.getElementById('playGameBtn');
        const statusDiv = document.getElementById('matchmakingStatus');
        
        try {
            cancelBtn.disabled = true;
            cancelBtn.textContent = 'Canceling...';

            console.log('Canceling matchmaking...');

            // Create the extrinsic (call_index 3 = cancelMatchmaking)
            const tx = this.api.tx.ticTacToe.cancelMatchmaking();

            // Sign and send based on account type
            let unsub;
            const txCallback = async (result) => {
                const { status, dispatchError } = result;
                console.log(`Matchmaking cancellation status:`, status.type);
                
                if (status.isInBlock) {
                    console.log(`Cancellation included in block at`, status.asInBlock.toString());
                    
                    // Check for errors
                    if (dispatchError) {
                        let errorInfo = '';
                        if (dispatchError.isModule) {
                            const decoded = this.api.registry.findMetaError(dispatchError.asModule);
                            errorInfo = `${decoded.section}.${decoded.name}: ${decoded.docs}`;
                        } else {
                            errorInfo = dispatchError.toString();
                        }
                        
                        console.error(`Cancellation error:`, errorInfo);
                        alert(`Failed to cancel matchmaking: ${errorInfo}`);
                    } else {
                        console.log('Successfully left matchmaking queue');
                        
                        // Reset UI
                        statusDiv.classList.add('hidden');
                        cancelBtn.classList.add('hidden');
                        playBtn.classList.remove('hidden');
                        playBtn.disabled = false;
                        playBtn.textContent = 'START GAME';
                    }
                    
                    cancelBtn.textContent = 'Cancel Matchmaking';
                    cancelBtn.disabled = false;
                    unsub();
                }
            };

            if (this.accountType === 'seed') {
                unsub = await tx.signAndSend(this.keyringPair, txCallback);
            } else {
                const injector = await web3FromAddress(this.currentAccount.address);
                unsub = await tx.signAndSend(
                    this.currentAccount.address,
                    { signer: injector.signer },
                    txCallback
                );
            }

        } catch (error) {
            console.error('Error canceling matchmaking:', error);
            alert(`Failed to cancel matchmaking: ${error.message}`);
            cancelBtn.textContent = 'Cancel Matchmaking';
            cancelBtn.disabled = false;
        }
    }

    async setupGame(gameId, playerX, playerO) {
        try {
            this.currentGameId = gameId;
            const currentAddr = this.currentAccount.address;

            console.log('Player X:', playerX);
            console.log('Player O:', playerO);
            console.log('Current Address:', currentAddr);

            if (currentAddr !== playerX && currentAddr !== playerO) {
                alert('You are not a player in this game');
                return;
            }

            // Determine which player we are
            this.opponentAddress = currentAddr === playerX ? playerO : playerX;
            this.currentPlayerSymbol = currentAddr === playerX ? 'X' : 'O';
            
            console.log(`You are Player ${this.currentPlayerSymbol}`);

            // Update UI with game info
            document.getElementById('gameIdValue').textContent = gameId;
            document.getElementById('playerXAddress').textContent = playerX;
            document.getElementById('playerOAddress').textContent = playerO;
            document.getElementById('gameIdDisplay').classList.remove('hidden');
            document.getElementById('gameInfoSection').classList.remove('hidden');
            document.getElementById('gameStatsBottom').classList.remove('hidden');
            document.getElementById('gameModeSection').style.display = 'none';
            document.getElementById('gameBoardContainer').classList.remove('hidden');

            // Load the board state from chain
            await this.refreshBoardFromChain();

            // Check game state
            const game = await this.api.query.ticTacToe.games(gameId);
            if (game.isSome) {
                const gameData = game.unwrap();
                const state = gameData.state;
                
                if (!state.isInProgress) {
                    this.gameActive = false;
                    const stateHuman = state.toHuman();
                    if (stateHuman === 'XWon' || state.isXWon) {
                        this.handleOnChainGameEnd(1);
                    } else if (stateHuman === 'OWon' || state.isOWon) {
                        this.handleOnChainGameEnd(2);
                    } else if (stateHuman === 'Draw' || state.isDraw) {
                        this.handleOnChainGameEnd(3);
                    }
                } else {
                    this.gameActive = true;
                }
            }

            // Update player turn
            await this.updatePlayerTurn();

            console.log(`Setup complete for game ${gameId} as Player ${this.currentPlayerSymbol}`);

        } catch (error) {
            console.error('Error setting up game:', error);
            alert(`Failed to setup game: ${error.message}`);
        }
    }

    async loadUserGames() {
        if (!this.api || !this.currentAccount) {
            return;
        }

        const dropdown = document.getElementById('gamesDropdown');
        const currentSelection = dropdown.value;

        try {
            const currentAddr = this.currentAccount.address;
            console.log('Loading games for:', currentAddr);

            // Get next game ID to know how many games exist
            const nextGameId = await this.api.query.ticTacToe.nextGameId();
            const totalGames = nextGameId.toNumber();

            console.log(`Checking ${totalGames} total games...`);

            // Fetch all games and filter for this player
            const userGames = [];
            for (let gameId = 0; gameId < totalGames; gameId++) {
                const game = await this.api.query.ticTacToe.games(gameId);
                
                if (game.isSome) {
                    const gameData = game.unwrap();
                    const playerXAddr = gameData.playerX || gameData.player_x;
                    const playerOAddr = gameData.playerO || gameData.player_o;
                    const playerX = playerXAddr.toString();
                    const playerO = playerOAddr.toString();
                    const state = gameData.state;
                    const stateHuman = state.toHuman();

                    // Check if user is in this game and it's in progress
                    if ((playerX === currentAddr || playerO === currentAddr) && 
                        (stateHuman === 'InProgress' || state.isInProgress)) {
                        userGames.push({
                            gameId,
                            playerX,
                            playerO,
                            isPlayerX: playerX === currentAddr,
                            opponent: (playerX === currentAddr ? playerO : playerX).slice(0, 12) + '...'
                        });
                    }
                }
            }

            console.log(`Found ${userGames.length} active games`);

            // Update dropdown
            dropdown.innerHTML = '<option value="">-- Select a game --</option>';
            
            if (userGames.length > 0) {
                userGames.forEach(game => {
                    const option = document.createElement('option');
                    option.value = game.gameId;
                    option.textContent = `Game #${game.gameId} - You are ${game.isPlayerX ? 'X' : 'O'} vs ${game.opponent}`;
                    dropdown.appendChild(option);
                });

                // Restore selection if it still exists
                if (currentSelection && userGames.some(g => g.gameId.toString() === currentSelection)) {
                    dropdown.value = currentSelection;
                }
            }

            // Update button state
            document.getElementById('joinSelectedGameBtn').disabled = !dropdown.value;

        } catch (error) {
            console.error('Error loading games:', error);
            dropdown.innerHTML = '<option value="">Error loading games</option>';
        }
    }

    async joinGameById(gameId) {
        try {
            // Query the game from storage
            const game = await this.api.query.ticTacToe.games(gameId);

            if (game.isNone) {
                alert(`Game ${gameId} not found`);
                return;
            }

            const gameData = game.unwrap();

            // Extract player addresses
            const playerXAddr = gameData.playerX || gameData.player_x;
            const playerOAddr = gameData.playerO || gameData.player_o;
            const playerX = playerXAddr.toString();
            const playerO = playerOAddr.toString();

            // Setup the game
            await this.setupGame(gameId, playerX, playerO);

        } catch (error) {
            console.error('Error joining game:', error);
            alert(`Failed to join game: ${error.message}`);
        }
    }

    async subscribeToGameEvents() {
        // Prevent subscribing multiple times
        if (this.eventsSubscribed || !this.api) {
            console.log('Events already subscribed or API not ready');
            return;
        }
        
        console.log('Subscribing to game events...');
        this.eventsSubscribed = true;
        
        // Subscribe to events for all games
        this.api.query.system.events(async (events) => {
            // Process MoveMade events first to update board before game ends
            for (const { event } of events) {
                if (this.api.events.ticTacToe.MoveMade.is(event)) {
                    const [gameId, player, position] = event.data;
                    if (gameId.toNumber() === this.currentGameId) {
                        console.log(`Move made in game ${gameId} by ${player} at position ${position}`);
                        // Refresh the board from chain before game potentially ends
                        await this.refreshBoardFromChain();
                    }
                }
            }
            
            // Then process other events
            events.forEach(({ event }) => {
                if (this.api.events.ticTacToe.GameCreated.is(event)) {
                    // New game created
                    const [gameId, playerX, playerO] = event.data;
                    console.log('New game created via matchmaking');
                    
                    // If we're waiting in matchmaking and this game includes us, join it
                    if (
                        (playerX.toString() === this.currentAccount.address || playerO.toString() === this.currentAccount.address) &&
                        !document.getElementById('matchmakingStatus').classList.contains('hidden')
                    ) {
                        console.log('Matched! Joining game...');
                        document.getElementById('matchmakingStatus').classList.add('hidden');
                        document.getElementById('playGameBtn').classList.remove('hidden');
                        document.getElementById('cancelMatchmakingBtn').classList.add('hidden');
                        this.setupGame(gameId.toNumber(), playerX.toString(), playerO.toString());
                    }
                }
                
                if (this.api.events.ticTacToe.GameEnded.is(event)) {
                    const [gameId, stateU8] = event.data;
                    console.log(`Game ${gameId} ended with state ${stateU8}`);
                    
                    if (gameId.toNumber() === this.currentGameId) {
                        console.log(`Current game ${gameId} ended with state: ${stateU8}`);
                        // Board should already be updated from MoveMade event
                        this.handleOnChainGameEnd(stateU8.toNumber());
                    }
                }
            });
        });
    }

    async refreshBoardFromChain() {
        if (!this.api || this.currentGameId === null) {
            return;
        }

        try {
            console.log(`Refreshing board for game ${this.currentGameId}...`);
            
            // Fetch the game state from chain
            const game = await this.api.query.ticTacToe.games(this.currentGameId);
            
            if (game.isNone) {
                console.error('Game not found');
                return;
            }

            const gameData = game.unwrap();
            const board = gameData.board;
            
            // Update the board UI
            board.forEach((cell, index) => {
                const cellElement = document.querySelector(`[data-cell="${index}"]`);
                const cellHuman = cell.toHuman();
                
                // Clear cell first
                cellElement.textContent = '';
                cellElement.classList.remove('taken', 'x', 'o');
                this.gameBoard[index] = null;
                
                // Set cell based on chain state
                if (cellHuman === 'X') {
                    this.gameBoard[index] = 'X';
                    cellElement.textContent = 'X';
                    cellElement.classList.add('taken', 'x');
                } else if (cellHuman === 'O') {
                    this.gameBoard[index] = 'O';
                    cellElement.textContent = 'O';
                    cellElement.classList.add('taken', 'o');
                }
            });

            // Update whose turn it is
            const xTurn = gameData.xTurn || gameData.x_turn;
            const isMyTurn = (this.currentPlayerSymbol === 'X' && xTurn) || 
                           (this.currentPlayerSymbol === 'O' && !xTurn);
            
            console.log(`Board refreshed. X's turn: ${xTurn}, My turn: ${isMyTurn}`);
            this.updatePlayerTurn();

        } catch (error) {
            console.error('Error refreshing board:', error);
        }
    }

    handleOnChainGameEnd(stateU8) {
        this.gameActive = false;
        
        const messageDiv = document.getElementById('gameMessage');
        let message = '';
        
        switch(stateU8) {
            case 1: // XWon
                message = 'üéâ Player X wins!';
                messageDiv.className = 'game-message winner';
                if (this.currentPlayerSymbol === 'X' || 
                    (this.currentPlayerSymbol === 'O' && this.currentAccount.address === this.opponentAddress)) {
                    this.gameStats.xWins++;
                    document.getElementById('xWins').textContent = this.gameStats.xWins;
                }
                break;
            case 2: // OWon
                message = 'üéâ Player O wins!';
                messageDiv.className = 'game-message winner';
                if (this.currentPlayerSymbol === 'O' || 
                    (this.currentPlayerSymbol === 'X' && this.currentAccount.address !== this.opponentAddress)) {
                    this.gameStats.oWins++;
                    document.getElementById('oWins').textContent = this.gameStats.oWins;
                }
                break;
            case 3: // Draw
                message = "ü§ù It's a draw!";
                messageDiv.className = 'game-message draw';
                this.gameStats.draws++;
                document.getElementById('draws').textContent = this.gameStats.draws;
                break;
        }
        
        messageDiv.textContent = message;
        messageDiv.classList.remove('hidden');
        this.saveGameStats();
    }

    async handleCellClick(cellIndex) {
        // Check if cell is already taken or game is not active
        if (this.gameBoard[cellIndex] || !this.gameActive) {
            return;
        }

        // Submit on-chain move
        if (this.currentGameId !== null) {
            await this.makeOnChainMove(cellIndex);
        } else {
            alert('Please create an on-chain game first');
        }
    }

    async makeOnChainMove(position) {
        if (!this.api || !this.currentAccount) {
            alert('Please connect to chain and wallet first');
            return;
        }

        try {
            console.log(`Making on-chain move: game ${this.currentGameId}, position ${position}`);

            // Create unique transaction ID
            const txId = `game_move_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

            // Create transaction history entry
            const txHistoryData = {
                id: txId,
                from: this.currentAccount.address,
                to: `Game #${this.currentGameId}`,
                amount: `Move at [${position}]`,
                status: 'pending',
                statusText: 'Signing...',
                hash: null,
                blockHash: null,
                timing: {
                    submitted: Date.now(),
                    ready: null,
                    broadcast: null,
                    inBlock: null,
                    finalized: null,
                    invalid: null
                }
            };

            const tx = this.api.tx.ticTacToe.makeMove(this.currentGameId, position);

            let unsub;
            const txCallback = (result) => {
                const { status } = result;

                console.log(`[${txId}] Move transaction status:`, status);
                if (status.isInvalid) {
                    console.error(`[${txId}] Move transaction is invalid`);
                    txHistoryData.timing.invalid = Date.now();
                    txHistoryData.status = 'error';
                    txHistoryData.statusText = 'Invalid';
                    this.addTransactionToHistory(txHistoryData);
                    unsub();
                    // Optionally, re-enable any UI elements if needed
                    return;
                }
                // Update hash if available
                if (!txHistoryData.hash && result.txHash) {
                    txHistoryData.hash = result.txHash.toHex();
                    console.log(`[${txId}] Transaction hash: ${txHistoryData.hash}`);
                }
                
                // Handle Ready status
                if (status.isReady) {
                    console.log(`[${txId}] Move transaction ready`);
                    txHistoryData.timing.ready = Date.now();
                    txHistoryData.statusText = 'Ready';
                    this.addTransactionToHistory(txHistoryData);
                    return;
                }

                // Handle InBlock status
                if (status.isInBlock) {
                    let events = [];
                    const blockHash = status.asInBlock;
                    this.api.query.system.events.at(blockHash).then(evts => {
                        events = evts;
                        console.log('events', events);

                        // The rest of the code that depends on events should be moved here if needed.
                        // However, since the surrounding code expects synchronous execution,
                        // you may need to refactor the callback to be async if you want to use await.
                        // For now, this will set events asynchronously.
                    }).catch(err => {
                        console.error(`[${txId}] Failed to read events from block:`, err);
                    });
                    

                    console.log('events', events);

                    // Handle extrinsic error: search for the specific extrinsic sent by the current account
                    if (events && Array.isArray(events)) {
                        // Find any ExtrinsicFailed event for the current account
                        const failedEvent = events.find(({ event, phase }) => {
                            // Only consider events in the ApplyExtrinsic phase
                            if (!phase || !phase.isApplyExtrinsic) return false;
                            // Check for system.ExtrinsicFailed
                            if (event.section !== 'system' || event.method !== 'ExtrinsicFailed') return false;
                            // Try to get the signer of the extrinsic from the event's extrinsic index
                            // phase.asApplyExtrinsic is the index of the extrinsic in the block
                            // We can try to get the extrinsic from the block if needed, but for now, check if this is the only failed event
                            return true;
                        });

                        if (failedEvent) {
                            let errorInfo = '';
                            let errorName = '';
                            const { event } = failedEvent;
                            if (event.data && event.data[0] && event.data[0].isModule) {
                                const moduleError = event.data[0].asModule;
                                const decoded = this.api.registry.findMetaError(moduleError);
                                errorInfo = `${decoded.section}.${decoded.name}: ${decoded.docs}`;
                                errorName = decoded.name;
                            } else if (event.data && event.data[0]) {
                                errorInfo = event.data[0].toString();
                                errorName = errorInfo;
                            }
                            // Optionally, check if the extrinsic was sent by the current account
                            // If available, you could fetch the extrinsic and check its signer
                            // For now, assume this is the user's extrinsic if we're in this callback
                            console.error(`[${txId}] Move failed (from events): ${errorInfo}`);
                            alert(`Move failed: ${errorName}`);
                            txHistoryData.status = 'error';
                            txHistoryData.statusText = `Error: ${errorName}`;
                            this.addTransactionToHistory(txHistoryData);

                            unsub();
                            return;
                        }
                    }

                    console.log(`[${txId}] Move included in block ${status.asInBlock.toHex()}`);
                    txHistoryData.timing.inBlock = Date.now();
                    txHistoryData.status = 'success';
                    txHistoryData.statusText = 'In Block';
                    txHistoryData.blockHash = status.asInBlock.toHex();
                    this.addTransactionToHistory(txHistoryData);
                }
                
                if (status.isFinalized) {
                    console.log(`[${txId}] Move finalized`);
                    txHistoryData.timing.finalized = Date.now();
                    txHistoryData.statusText = 'Finalized ‚úì';
                    txHistoryData.finalizedBlockHash = status.asFinalized.toHex();
                    
                    // Update in history
                    this.updateTransactionInHistory(txHistoryData.hash, {
                        status: 'success',
                        statusText: 'Finalized ‚úì',
                        finalizedBlockHash: status.asFinalized.toHex(),
                        timing: txHistoryData.timing
                    });
                    
                    
                    unsub();
                }
            };

            if (this.accountType === 'seed') {
                unsub = await tx.signAndSend(this.keyringPair, txCallback);
            } else {
                const injector = await web3FromAddress(this.currentAccount.address);
                unsub = await tx.signAndSend(
                    this.currentAccount.address,
                    { signer: injector.signer },
                    txCallback
                );
            }

        } catch (error) {
            console.error('Error making move:', error);
            alert(`Failed to make move: ${error.message}`);
        }
    }

    async updatePlayerTurn() {
        const playerIndicator = document.getElementById('currentPlayer');
        
        if (!this.api || this.currentGameId === null) {
            playerIndicator.textContent = `You are Player ${this.currentPlayerSymbol}`;
            playerIndicator.className = `player-indicator player-${this.currentPlayerSymbol.toLowerCase()}`;
            return;
        }

        try {
            // Fetch current game state to check whose turn it is
            const game = await this.api.query.ticTacToe.games(this.currentGameId);
            if (game.isSome) {
                const gameData = game.unwrap();
                
                // Debug: log the full game data structure
                console.log('GameData for turn update:', gameData.toHuman());
                console.log('GameData JSON:', gameData.toJSON());
                
                // Try both possible field names
                const xTurn = gameData.xTurn !== undefined ? gameData.xTurn : 
                             gameData.x_turn !== undefined ? gameData.x_turn :
                             gameData.toJSON().xTurn !== undefined ? gameData.toJSON().xTurn :
                             gameData.toJSON().x_turn;
                
                console.log('xTurn value:', xTurn, 'type:', typeof xTurn);
                console.log('My symbol:', this.currentPlayerSymbol);
                
                const isMyTurn = (this.currentPlayerSymbol === 'X' && xTurn) || 
                               (this.currentPlayerSymbol === 'O' && !xTurn);
                
                const turnPlayer = xTurn ? 'X' : 'O';
                const turnText = isMyTurn ? 
                    `üéØ Your Turn (Player ${this.currentPlayerSymbol})` : 
                    `‚è≥ Waiting for Player ${turnPlayer}`;
                
                console.log(`Turn update: xTurn=${xTurn}, turnPlayer=${turnPlayer}, mySymbol=${this.currentPlayerSymbol}, isMyTurn=${isMyTurn}`);
                
                playerIndicator.textContent = turnText;
                // Show indicator based on whose turn it actually is
                playerIndicator.className = `player-indicator player-${turnPlayer.toLowerCase()}`;
            }
        } catch (error) {
            console.error('Error updating player turn:', error);
            playerIndicator.textContent = `Player ${this.currentPlayerSymbol}'s turn`;
            playerIndicator.className = `player-indicator player-${this.currentPlayerSymbol.toLowerCase()}`;
        }
    }

    resetGame() {
        // Reset game state
        this.gameBoard = Array(9).fill(null);
        this.currentPlayerSymbol = 'X';
        this.gameActive = true;
        this.currentGameId = null;
        this.opponentAddress = null;

        // Clear all cells
        document.querySelectorAll('.cell').forEach(cell => {
            cell.textContent = '';
            cell.className = 'cell';
        });

        // Hide message
        document.getElementById('gameMessage').classList.add('hidden');
        
        // Reset matchmaking UI
        const playBtn = document.getElementById('playGameBtn');
        if (playBtn) {
            playBtn.disabled = false;
            playBtn.textContent = 'START GAME';
            playBtn.classList.remove('hidden');
        }
        
        const cancelBtn = document.getElementById('cancelMatchmakingBtn');
        if (cancelBtn) {
            cancelBtn.classList.add('hidden');
        }
        
        const statusDiv = document.getElementById('matchmakingStatus');
        if (statusDiv) {
            statusDiv.classList.add('hidden');
        }
        
        // Reset on-chain UI elements
        document.getElementById('gameIdDisplay').classList.add('hidden');
        document.getElementById('gameInfoSection').classList.add('hidden');
        document.getElementById('gameStatsBottom').classList.add('hidden');
        document.getElementById('gameBoardContainer').classList.add('hidden');
        document.getElementById('gameModeSection').style.display = 'block';

        // Reset player turn display
        this.updatePlayerTurn();
    }

    saveGameStats() {
        localStorage.setItem('tictactoe_stats', JSON.stringify(this.gameStats));
    }

    loadGameStats() {
        const saved = localStorage.getItem('tictactoe_stats');
        if (saved) {
            try {
                this.gameStats = JSON.parse(saved);
                document.getElementById('xWins').textContent = this.gameStats.xWins;
                document.getElementById('oWins').textContent = this.gameStats.oWins;
                document.getElementById('draws').textContent = this.gameStats.draws;
            } catch (e) {
                console.error('Failed to load game stats:', e);
            }
        }
    }
}

// Initialize the app when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    new PolkadotApp();
}); 